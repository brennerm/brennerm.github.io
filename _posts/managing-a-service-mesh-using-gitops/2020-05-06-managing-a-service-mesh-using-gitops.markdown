---
layout: post
title: Managing a service mesh using GitOps
description: Learn how to manage a service mesh installation using GitOps. In this guide I'm using Linkerd and Argo CD but any equivalents will work.
category: posts
tags: kubernetes servicemesh gitops linkerd argocd
draft: false
---
## the idea

If you've ever set up a service mesh, like [Linkerd](https://linkerd.io/) or [Istio](https://istio.io/) you know that most of them are being installed by applying Kubernetes manifests (or anything alike) to your cluster. The easiest way to generate these manifests is using the CLI tools (`linkerd install` or `istioctl manifest generate`). Afterwards pipe their output to `kubectl apply -f -` and you are good to go.

Using this approach for a playground cluster is totally fine but for a productive cluster I see a few issues:

#### **missing reproducibility**

Think anyone can remember the output of the `linkerd install` command used for the initial installation of the service mesh? It contains around 100 different Kubernetes resources so I'd assume that no human being is capable of doing so. But what if you want transfer the exact same setup to a different cluster or want to reinstall you current cluster while keeping its configuration?

#### **security concerns**

Piping any Kubernetes manifests to `kubectl apply -f -` is the new `curl -L https://randomdomain.com/install.sh | bash` and I'm by no means innocent in this regard. But when I'm running a cluster for someone that really counts on its trustworthiness being in control of what I deploy has one of the highest priorities. Additionally I'd like to make sure that my manifests follow an appropriate level of security guidelines.

#### **missing traceability**

Any idea what changed in the latest minor version of Istio? Me neither and to be honest in most cases I don't care. That is, if after the upgrade my application works just fine. Otherwise I'd try to fix the issue myself or roll back to the previous version. Both would be significantly easier if I knew what has changed.

#### **having no single source of truth**

What is the desired state of our service mesh? What if my colleague executes an upgrade with his ten month old version of the *linkerd* CLI tool and thus downgrades the whole system by accident? Who takes care of fixing it? The ease of use of Kubernetes manifests makes it very tempting to apply changes directly from your computer. The same applies to everyone having administrative access to your cluster and thus can lead to configurations being overwritten regularly or applying erroneous settings.

All of these problems can at least partly being solved by using the GitOps approach.
- explain GitOps

## preparation

Before we can start we need to setup a Kubernetes cluster and a GitOps tool of choice. I'm going with Argo CD but something like Flux will work just fine. If you want to be ready to go within 5 minutes feel free to use (my snippet](https://gitlab.com/snippets/1967592) that uses [kind](https://kind.sigs.k8s.io/) to create a local Kubernetes cluster and afterwards prepares an Argo instance. Otherwise set up your own cluster and install Argo by following their [Getting Started](https://argoproj.github.io/argo-cd/getting_started/).

As soon as you are able to log into the Argo Web UI or using the CLI we are ready to continue.

## installation and upgrading

At first you gotta decide for a service mesh to go with. I'll use Linkerd 2 but again everything else that is installable using Kubernetes manifests will work just fine. With Linkerd these are being generated by executing `linkerd install`. Saving the output to a file, creating a Git repo and pushing this file to it will be everything we need for now. Additionally you could split up the single manifest into separate files for each resource by using something like [kubernetes-split-yaml](https://github.com/mogensen/kubernetes-split-yaml). This will make reviewing changes later on much easier.

Afterwards we are ready to create our service mesh Argo CD application:

```bash
argocd app create linkerd \
    --repo https://mycompany.com/service-mesh-deployment.git \ # the URL of our Git repository containing the Kubernetes manifests
    --path . \ # the path of our Kubernetes manifests within the Git repo
    --dest-server https://kubernetes.default.svc \ # the destination cluster we want to deploy to
    --dest-namespace linkerd # the destination namespace we want to deploy to
```

Manually sync the app with `argocd app sync linkerd` and we should have a running service mesh after a few minutes.

To be sure your cluster is ready to run Linkerd it provides a pretty cool pre check that you can execute with `linkerd check --pre`. This is definitely something that you can integrate into you CI pipeline before 

---
